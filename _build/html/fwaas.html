
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <title>FWaaS internal &mdash; neutron internal 0 ドキュメント</title>
  
    <link rel="stylesheet" href="_static/general.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
  <!-- Sticky footer -->
  <!--[if  IE 8]>
  <style type="text/css">
    #wrap {display:table;}
  </style>
  <![endif]--> 
</head>
<body>
<div id="wrapper">
  
  <!-- header -->
  <div id="header">
    <div id="projInfo">
      <h1 id="title">
        <a href="index.html">neutron internal</a>
      </h1>
      <p class="docdesc">neutron internal 0 ドキュメント</p>
    </div>
    <div id="headerNav">
      <div id="searchbox">
        <form name="search" action="search.html" method="get">
          <fieldset class="search">
            <input type="text" class="hint" name="q" />
            <button class="button" title="検索" />検索</button>
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </fieldset>
        </form>
      </div>
    </div>
    <script type="text/javascript">$('#searchbox').show(0);</script>
<div id="gnav">
  <ul>
    <li class="home"><p><a href="index.html" title="neutron internal">neutron internal</a></p></li>
    <li class="doc"><p><a href="index.html" title="ドキュメント">ドキュメント</a></p></li>
    <li class="modindex">
      <p><a title="索引" href="genindex.html">索引</a></p>
    </li>
  </ul>
</div>
  </div>
  <!-- /header -->
  
  
  <!-- content -->
  <div id="content">
    <!-- current document area -->
    <div id="document" class="left">
  <div class="section" id="fwaas-internal">
<h1>FWaaS internal<a class="headerlink" href="#fwaas-internal" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="fwaas">
<h2>FWaaSの構造<a class="headerlink" href="#fwaas" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div>L3NATAgentにFWaaS関連のモジュール(#1)を組み込むことで実現している。何か特殊なエージェントが別に起動するわけではない。
(#1) firewall_l3_agent.FWaaSL3AgentRpcCallback</div></blockquote>
</div>
<div class="section" id="firewall-l3-agent-fwaasl3agentrpccallback">
<h2>firewall_l3_agent.FWaaSL3AgentRpcCallback ★エージェント側<a class="headerlink" href="#firewall-l3-agent-fwaasl3agentrpccallback" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>[ファイル]</p>
<p>neutron/services/firewall/agents/l3reference/firewall_l3_agent.py</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>__init__</dt>
<dd><ul class="first last simple">
<li><strong>説明：各種初期化を行う</strong></li>
<li>fwaas_plugin_configured and fwaas_enabledがfalseの場合、は異常終了</li>
<li>fwaas_enabledがtrueの場合、fwaas_driverを読み込み。</li>
<li>self.services_sync = Falseに設定(何?)</li>
<li>fwplugin_rcpのセットアップ</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">_get_router_info_list_for_tenant(self, routers, tenant_id)</p>
<blockquote>
<div><ul class="simple">
<li><strong>説明：所有者がtenant_idかつ、自分(l3 agnet)が担当しており、かつ、network namespaceが起動しているrouterをroutersから探してリストで返す</strong></li>
<li>routersの中から、tenant_idに一致するrouter情報を抽出(router_ids)</li>
<li>router_idsの中のrouterで、自分(l3 agent)が担当していないrouterはスキップ</li>
<li>router_idsの中のrouterで、そのrouterのnetwork namespaceが起動している場合は、router_info_listにrouter idを追加</li>
<li>router_info_listを返却</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">_invoke_driver_for_plugin_api(self, context, fw, func_name)</p>
<blockquote>
<div><ul class="simple">
<li><strong>説明：self.fwaas_driverのfunc_nameを呼び出す(呼び出す前後で処理がある。func_nameを呼び出す前にrouterのチェック。tenantにrouterが無い場合は、なにもしない。func_nameを呼び出した後、その結果に応じてstatusを変化させる(fwがadmin_state_upの場合、ACTIVE。そう出ない場合はDOWN。fw_ext.FirewallInternalDriverError:の場合はERROR))</strong></li>
<li>neutron serverからすべてのルータの情報を取得(self.plugin_rpc.get_routers(context))★この処理は大変重くないか？</li>
<li>_get_router_info_list_for_tenantでrouter絞り込み。結果をrouter_info_listに代入</li>
<li>もし、router_info_listが[]の場合、かつ、func_nameが&#8221;delete_firewall&#8221;の場合、self.fwplugin_rpc.firewall_deleted(context, fw[&#8216;id&#8217;)]を実行してreturn。もし、router_info_listが[]の場合、かつ、func_nameが&#8221;delete_firewall&#8221;でない場合はreturn</li>
<li>router_info_listが[]出ない場合、以降を実行</li>
<li>self.fwaas_driverのfunc_nameを呼び出す(引数：router_info_list,fw)</li>
<li>もし、fw[&#8220;admin_state_up&#8221;]が真の場合、status = constants.ACTIVE。偽の場合、status = constants.DOWN。fw_ext.FirewallInternalDriverError:が発生した場合は、status = constants.ERROR</li>
<li>func_name == &#8220;delete_firewall&#8221;の場合、かつ、statusがconstants.ACTIVEまたは、constants.DOWNの場合、self.fwplugin_rpc.firewall_deleted(context, fw[&#8216;id&#8217;])を呼び出す</li>
<li>func_nameが&#8221;delete_firewall&#8221;でない場合、self.fwplugin_rpc.set_firewall_status(context,fw[&#8216;id&#8217;],status)を実行。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">_invoke_driver_for_sync_from_plugin(self, ctx, router_info_list, fw)</p>
<blockquote>
<div><ul class="simple">
<li><strong>説明:fwのstatusに応じてfwaas_driverのメソッドを呼ぶ(PENDING_DELETE -&gt; delete_firewall, それ以外、update_firewall)</strong></li>
<li>fw[&#8216;status&#8217;] == constants.PENDING_DELETE:の場合、self.fwaas_driver.delete_firewall(router_info_list, fw)を実行し、self.fwplugin_rpc.firewall_deletedを実行する。例外が発生した場合は、self.fwplugin_rpc.set_firewall_status(constants.ERROR)でエラー状態へ遷移する。</li>
<li>fw[&#8216;status&#8217;] == constants.PENDING_DELETE:以外の場合(PENDING_UPDATE, PENDING_CREATE, ...)、self.fwaas_driver.update_firewall(router_info_list, fw)を実行する。実行後fw[&#8216;admin_state_up&#8217;]:の場合、statusをACTIVEにする。fw[&#8216;admin_state_up&#8217;]:以外の場合、statusをDOWNにする。update_firewallで例外が発生した場合、ERROR状態へ遷移する。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">_process_router_add(self, ri):</p>
<ul class="simple">
<li><strong>説明：ルータが追加された場合、そのルータ(ri)に対してself._invoke_driver_for_sync_from_pluginを適用する</strong></li>
<li>routers配列を[]で初期化して、riを追加。</li>
<li>self._get_router_info_list_for_tenant(routers,ri.router[&#8216;tenant_id&#8217;])を実行(結果をrouter_info_listで受ける)</li>
<li>router_info_listが空でない場合、self.fwplugin_rpc.get_firewalls_for_tenant(ctx)を実行し、該当テナントのFWリストを得る(fw_listで受ける)。fw_listのそれぞれに対して、self._invoke_driver_for_sync_from_plugin(router_info_list,fw)を実行。</li>
</ul>
</li>
<li><p class="first">process_router_add(self, ri):</p>
<ul class="simple">
<li><strong>説明：_process_router_addのラッパ</strong></li>
<li>self.fwaas_enabledがFalseの場合、return</li>
<li>self._process_router_add(ri)を実行する。例外が発生した場合、self.services_sync = Trueを実行。</li>
</ul>
</li>
<li><p class="first">process_services_sync(self, ctx):</p>
<ul class="simple">
<li><strong>説明：すべてのFWの適用を、FWに対応したルータに対して行う</strong></li>
<li>self.fwaas_enabledがFalseの場合、return</li>
<li>self.plugin_rpc.get_routers(ctx)ですべてのrouterを取得(routersで受ける)</li>
<li>self.fwplugin_rpc.get_tenants_with_firewalls(ctx)でFWを持っているテナントのリストを得る(tenant_idsで受ける)</li>
<li>tenant_idsのそれぞれのidに対して、以下を実行</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>self.fwplugin_rpc.get_firewalls_for_tenant(ctx)でtenantが持っているFWのリストを得る(fw_listで受ける)</li>
<li>fw_listが空でないばあい、以下を実行<ul>
<li>self._get_router_info_list_for_tenant(routers,tenant_id)を実行し、テナントのrouterを得る(router_info_listで受ける)</li>
<li>router_info_listが空でない場合、fw_listのそれぞれに対して以下を実行
- self._invoke_driver_for_sync_from_plugin(ctx,router_info_list,fw)</li>
</ul>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">create_firewall(self, context, firewall, host)</p>
<ul class="simple">
<li>_invoke_driver_for_plugin_api(context,firewall,&#8217;create_firewall&#8217;)を実行する</li>
</ul>
</li>
<li><p class="first">update_firewall(self, context, firewall, host)</p>
<ul class="simple">
<li>_invoke_driver_for_plugin_api(context,firewall,&#8217;update_firewall&#8217;)を実行する</li>
</ul>
</li>
<li><p class="first">delete_firewall(self, context, firewall, host)</p>
<ul class="simple">
<li>_invoke_driver_for_plugin_api(context,firewall,&#8217;delete_firewall&#8217;)を実行する</li>
</ul>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="fwaas-driver">
<h2>FWaaS driver処理 ★エージェント側<a class="headerlink" href="#fwaas-driver" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>(未稿)</p>
</div>
<div class="section" id="class-firewallcallbacks-n-rpc-rpccallback">
<h2>class FirewallCallbacks(n_rpc.RpcCallback) ★プラグイン側<a class="headerlink" href="#class-firewallcallbacks-n-rpc-rpccallback" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>[ファイル]
neutron/services/firewall/fwaas_plugin.py</p>
<p>[概要]
AMQPのイベントごとに実行されるコールバックの定義</p>
<blockquote>
<div><ul>
<li><p class="first">__init__(self, plugin):</p>
<ul class="simple">
<li><strong>説明：初期化を実施</strong></li>
<li>super(FirewallCallbacks, self).__init__()</li>
<li>self.plugin = plugin</li>
</ul>
</li>
<li><p class="first">set_firewall_status(self, context, firewall_id, status, <a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs):</p>
<ul class="simple">
<li><strong>説明：Firewallのstatusを変更する。ただし、PENDING_DELETEの場合は変更しない</strong></li>
<li>self.plugin._get_firewall(context, firewall_id)でfwを取得する</li>
<li>fwの状態がPENDING_STATUSの場合はFalseで返る</li>
<li>statusが(const.ACTIVE, const.INACTIVE, const.DOWN)のいずれかの場合はfwのstatusを更新してTrueで返る</li>
<li>statusが上記以外であれば、ERRORをfwにセットしてFalseで返る</li>
</ul>
</li>
<li><p class="first">firewall_deleted(self, context, firewall_id, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs):</p>
<ul class="simple">
<li><strong>説明：firewallをdeleted状態にするために、Agnetが使うRPCメソッド</strong></li>
<li>self.plugin._get_firewall(context, firewall_id)でfwを取得する</li>
<li>fwの状態がconst.PENDING_DELETEまたは、const.ERRORの場合
- DBからfwを削除する
- Trueで返る</li>
<li>fwの状態が上記以外の場合
- fwの状態をERRORにセットする
- Falseで返る</li>
</ul>
</li>
<li><p class="first">get_firewalls_for_tenant(self, context, <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs):</p>
<ul class="simple">
<li><strong>説明: tenantのfirewallを得る(ルールあり)</strong></li>
<li>self.plugin.get_firewalls(context)を呼び出し、返ってくる個々のfwに対して、self.plugin._make_firewall_dict_with_rules(context, fw[&#8216;id&#8217;])を呼び出しdictに変換して返す</li>
</ul>
</li>
<li><p class="first">get_firewalls_for_tenant_without_rules(self, context, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs):</p>
<ul class="simple">
<li><strong>説明：tenantのfirewallを得る(ルールなし)</strong></li>
<li>self.plugin.get_firewalls(context)を呼び出し、返ってくるものをリスト化して返す</li>
</ul>
</li>
<li><dl class="first docutils">
<dt>get_tenants_with_firewalls(self, context, <a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallを所有しているtenantを得る(agentがfirewallを保持するすべてのテナントを得るために使用する)</strong></li>
<li>neutron_context.get_admin_context()で管理者コンテキストを得る</li>
<li>self.plugin.get_firewalls(ctx)でfirewallを得る</li>
<li>tenant_idでフィルタリングしてfwのリストを返す</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="class-firewallagentapi-n-rpc-rpcproxy">
<h2>class FirewallAgentApi(n_rpc.RpcProxy): ★プラグイン側<a class="headerlink" href="#class-firewallagentapi-n-rpc-rpcproxy" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>[ファイル]
neutron/services/firewall/fwaas_plugin.py</p>
<p>[概要]
プラグイン側のagentのRPC APIを呼び出すためのラッパー</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>__init__(self, topic, host):</dt>
<dd><ul class="first last simple">
<li><strong>説明：各種初期化を行う</strong></li>
<li>self.hostにhostを代入する</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>create_firewall(self, context, firewall):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewallの作成を行う</strong></p>
</li>
<li><dl class="first docutils">
<dt>self.fanout_castを呼び出し、エージェントへ通知する</dt>
<dd><ul class="first last simple">
<li>&#8220;create_firewall&#8221;, firewall=firewal, host=self.host</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>update_firewall(self, context, firewall):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewallの更新を行う</strong></p>
</li>
<li><dl class="first docutils">
<dt>self.fanout_castを呼び出し、エージェントへ通知する</dt>
<dd><ul class="first last simple">
<li>&#8220;update_firewall&#8221;, firewall=firewal, host=self.host</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delete_firewall(self, context, firewall):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewallの削除を行う</strong></p>
</li>
<li><dl class="first docutils">
<dt>self.fanout_castを呼び出し、エージェントへ通知する</dt>
<dd><ul class="first last simple">
<li>&#8220;delete_firewall&#8221;, firewall=firewal, host=self.host</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="class-firewallcountexceeded-n-exception-conflict">
<h2>class FirewallCountExceeded(n_exception.Conflict): ★プラグイン側<a class="headerlink" href="#class-firewallcountexceeded-n-exception-conflict" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>[ファイル]
neutron/services/firewall/fwaas_plugin.py</p>
<p>[概要]
Firewallの個数が超過したときに発生する例外</p>
</div>
<div class="section" id="class-firewallplugin-firewall-db-firewall-db-mixin">
<h2>class FirewallPlugin(firewall_db.Firewall_db_mixin): ★プラグイン側<a class="headerlink" href="#class-firewallplugin-firewall-db-firewall-db-mixin" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>[ファイル]
neutron/services/firewall/fwaas_plugin.py</p>
<p>[概要]
Neutron Firewall Service Pluginの実装。FWaaS request/responseのワークフローを管理する。DB関連の仕事のほとんどはfirewall_db.Firewall_db_mixinで実装されている。</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>__init__(self, topic, host):</dt>
<dd><ul class="first last simple">
<li><strong>説明：各種初期化を行う(以下、各処理は要調査)</strong></li>
<li>qdbapi.register_models()でモデルの登録を行う</li>
<li>self.endpoints = [FirewallCallbacks(self)]でエンドポイントをFirewallCallbacksに設定</li>
<li>self.conn = n_rpc.create_connection(new=True)でAMQPサーバに接続する</li>
<li>AMQPにconsumerの設定を行う(topics=q-firewall-plugin,FirewallCallbacks,fanout=False)</li>
<li>agent_rpcの初期化を行う(FierwallAgentApi)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_make_firewall_dict_with_rules(self, context, firewall_id):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明:rule付きのFirewallの情報を返す</strong></p>
</li>
<li><p class="first">firewall_idでfirewallをDBから検索する</p>
</li>
<li><p class="first">検索結果からfirewall_policy_idを得る</p>
</li>
<li><dl class="first docutils">
<dt>firewall_policy_idがある場合</dt>
<dd><ul class="first last simple">
<li>fw_policy_idでfireall_policyをDBから検索する</li>
<li>fw_policyの個々のfirewall_rulesについてrule_idでDBからFirewallRuleを検索する</li>
<li>firewall[&#8216;firewall_rule_list&#8217;]に結果を代入する</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">firewall_policy_idが存在しない場合、firewall[&#8216;firewall_rule_list&#8217;]に[]を代入する</p>
</li>
<li><p class="first">結果(firewall)を返却する</p>
</li>
<li><p class="first">[メモ]このメソッドで作成されたfirewallオブジェクトのサイズが、rabbit/qpidがサポートするサイズを越えた場合、問題が発生する！！！</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_rpc_update_firewall(self, context, firewall_id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：DBのFirewallの状態をupdateしたあとで、agentにupdateを通知する</strong></li>
<li>super(FirewallPlugin, self).update_firewallでfirewallの状態をPENDING_UPDATE状態に変更する</li>
<li>self._make_firewall_dict_with_rulesでfirewallの情報を得る。</li>
<li>self.agent_rpc.update_firewall(context, fw_with_rules)でagentにupdateの通知を行う</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_rpc_update_firewall_policy(self, context, firewall_policy_id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall_policy_idに関連付くfireweallの状態をPENDING_UPDATE状態に変更する</strong></li>
<li>firewall_policyのfirewall_listの各firewallについて、self._rpc_update_firewall(context, firewall_id)を実行する</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_ensure_update_firewall(self, context, firewall_id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallの状態がPENDING_CREATE or PENDING_UPDATE or PENDING_DELETEの場合はFirewallInPendingState例外を発生する</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_ensure_update_firewall_policy(self, context, firewall_policy_id):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewall_policyに関連づくfirewallの状態をPENDING_UPDATE状態に設定する</strong></p>
</li>
<li><p class="first">firewall_policy_idをキーとしてDBからfirewall_policyを検索する</p>
</li>
<li><dl class="first docutils">
<dt>policyが存在し、かつ、firewall_policyにfirewall_listが存在する場合は以下を実行</dt>
<dd><ul class="first last simple">
<li>各firewallについて、self._ensure_update_firewall(context, firewall_id)を実行する</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_ensure_update_firewall_rule(self, context, firewall_rule_id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall_ruleに関連づくfiewallの状態をupdateする</strong></li>
<li>firewall_rule_idをキーとしてDBからfirewall_ruleを検索する</li>
<li>fw_ruleが存在し、かつ、fw_ruleにfirewall_policy_idが存在する場合、self._ensure_update_firewall_policyを実行し、firewallの状態をPENDING_UPDATE状態に設定する</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>create_firewall(self, context, firewall):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallの作成を行う</strong></li>
<li>self._get_tenant_id_for_createでfirewallのtenant_idを得る。</li>
<li>self.get_firewalls_countでfirewallの個数を得る</li>
<li>fw_countがある場合、FirewallCountExceeded(tenant_id=tenant_id)例外をraiseする</li>
<li>firewallの状態をPENDING_CREATE状態に設定する</li>
<li>super(FirewallPlugin, self).create_firewall(context, firewall)を実行する(firewall_db.Firewall_db_mixin)</li>
<li>self._make_firewall_dict_with_rules(context, fw[&#8216;id&#8217;]))を実行してrule付きのfw情報を作る</li>
<li>self.agent_rpc.create_firewall(context, fw_with_rules)でfirewallがcreateされたことをagentに通知する</li>
<li>fw情報を返す</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>update_firewall(self, context, id, firewall):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallの状態を更新する</strong></li>
<li>self._ensure_update_firewall(context, id)でfirewallの状態をチェックする</li>
<li>firewallの状態をPENDING_UPDATEに設定する</li>
<li>fw = super(FirewallPlugin, self).update_firewall(context, id, firewall)を実行する(firewall_db.Firewall_db_mixin)</li>
<li>self._make_firewall_dict_with_rules(context, fw[&#8216;id&#8217;]))を実行してrule付きのfw情報を得る</li>
<li>self.agent_rpc.update_firewall(context, fw_with_rules)でagnetに状態の更新を通知する</li>
<li>fwを返す</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delete_firewall(self, context, id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallを削除する</strong></li>
<li>fw = super(FirewallPlugin, self).update_firewallでfirewallの状態をPENDING_DELETEに設定する</li>
<li>self._make_firewall_dict_with_rules(context, fw[&#8216;id&#8217;]))でrule付きのfirewallの情報を作成する</li>
<li>self.agent_rpc.delete_firewall(context, fw_with_rules)でagentに状態の更新を通知する</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>update_firewall_policy(self, context, id, firewall_policy):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall policyを更新する</strong></li>
<li>self._ensure_update_firewall_policy(context, id)で状態をチェックする</li>
<li>fwp = super(FirewallPlugin,self).update_firewall_policy(context, id, firewall_policy)を実行する</li>
<li>self._rpc_update_firewall_policy(context, id)でagentに状態の更新を通知する</li>
<li>firewall ruleを返す</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>update_firewall_rule(self, context, id, firewall_rule):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall ruleを更新する</strong></li>
<li>self._ensure_update_firewall_rule(context, id)で状態をチェックする</li>
<li>fwr = super(FirewallPlugin,self).update_firewall_rule(context, id, firewall_rule)を実行する</li>
<li>self._rpc_update_firewall_policy(context, firewall_policy_id)でagentに通知する</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>insert_rule(self, context, id, rule_info):</dt>
<dd><ul class="first last simple">
<li><strong>説明：ruleをinsertする</strong></li>
<li>self._ensure_update_firewall_policy(context, id)で状態をチェックする</li>
<li>fwp = super(FirewallPlugin,self).insert_rule(context, id, rule_info)を実行する</li>
<li>self._rpc_update_firewall_policy(context, id)でagnetに通知する</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>remove_rule(self, context, id, rule_info):</dt>
<dd><ul class="first last simple">
<li><strong>説明：ruleをremoveする</strong></li>
<li>self._ensure_update_firewall_policy(context, id)で状態をチェックする</li>
<li>fwp = super(FirewallPlugin,self).remove_rule(context, id, rule_info)を実行する</li>
<li>self._rpc_update_firewall_policy(context, id)を実行してagentに通知する</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="db">
<h2>DBレコード構造★<a class="headerlink" href="#db" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>[ファイル]
neutron/db/firewall/firewall_db.py</p>
<ul>
<li><dl class="first docutils">
<dt>class FirewallRule(model_base.BASEV2, models_v2.HasId, models_v2.HasTenant)</dt>
<dd><ul class="first last simple">
<li>PK:ID</li>
<li>FK:firewall_policies.id</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>class Firewall(model_base.BASEV2, models_v2.HasId, models_v2.HasTenant):</dt>
<dd><ul class="first last simple">
<li>PK:ID</li>
<li>FK:firewall_policies.id</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>class FirewallPolicy(model_base.BASEV2, models_v2.HasId, models_v2.HasTenant):</dt>
<dd><ul class="first last">
<li><p class="first">PK:ID</p>
</li>
<li><dl class="first docutils">
<dt>firewall_rules = orm.relationship(</dt>
<dd><p class="first last">FirewallRule,
backref=orm.backref(&#8216;firewall_policies&#8217;, cascade=&#8217;all, delete&#8217;),
order_by=&#8217;FirewallRule.position&#8217;,
collection_class=ordering_list(&#8216;position&#8217;, count_from=1))</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="firewall-db-firewall-db-mixin">
<h2>firewall_db.Firewall_db_mixin: ★プラグイン側<a class="headerlink" href="#firewall-db-firewall-db-mixin" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>[ファイル]
neutron/db/firewall/firewall_db.py</p>
<p>[概要]
firewall pluginのDB関連の処理を行うmixin</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>_core_plugin(self):</dt>
<dd><ul class="first last simple">
<li><strong>説明：プラグインを返す</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_get_firewall(self, context, id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallをidをキーとして検索する</strong></li>
<li>self._get_by_id(context, Firewall, id)でレコードを検索する</li>
<li>※例外をキャッチして、NoResultFountの場合はfirewall.FirewallNotFound(firewall_id=id)をraiseする</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_get_firewall_policy(self, context, id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall policyを返す</strong></li>
<li>return self._get_by_id(context, FirewallPolicy, id)</li>
<li>※例外をキャッチして、NoResultFountの場合はfirewall.FirewallPolicyNotFound(firewall_policy_id=id)をraiseする</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_get_firewall_rule(self, context, id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall ruleを返す</strong></li>
<li>return self._get_by_id(context, FirewallRule, id)</li>
<li>※例外をキャッチして、NoResultFountの場合はfirewall.FirewallRuleNotFound(firewall_rule_id=id)をraiseする</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_make_firewall_dict(self, fw, fields=None):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall情報をdictにして返す</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_make_firewall_policy_dict(self, firewall_policy, fields=None):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall policy情報をdictにして返す</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_make_firewall_rule_dict(self, firewall_rule, fields=None):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewall rule情報をdictにして返す</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_set_rules_for_policy(self, context, firewall_policy_db, rule_id_list):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewall_policy(firewall_policy_db)にrule(rule_id_list)を設定する</strong></p>
</li>
<li><p class="first">context.session.begin(subtransactions=True):を実行する</p>
</li>
<li><p class="first">fwp_db = firewall_policy_dbを実行する</p>
</li>
<li><p class="first">rule_id_listが無い場合、fwp_db.firewall_rulesに[]を設定し、fwp_db.audited=Falseに設定してreturnする</p>
</li>
<li><p class="first">rule_id_listからidを抽出してリスト化する(filters変数にセット)</p>
</li>
<li><p class="first">self._get_collection_queryを使って、filtersをキーとしてfirewall ruleをDBから検索する(rules_in_db変数にセット)</p>
</li>
<li><p class="first">検索結果のrules_in_dbからdictを生成する(rule_dict変数にセット)</p>
</li>
<li><dl class="first docutils">
<dt>rule_id_listをループ(fwrule_id)</dt>
<dd><ul class="first last simple">
<li>fwrule_idがrules_dictに含まれていない場合は、firewall.FirewallRuleNotFoundをraiseする</li>
<li>rules_dict[fwrule_id][&#8216;firewall_policy_id&#8217;]が、fwp_db[&#8216;id&#8217;]と異なる場合は、firewall.FirewallRuleInUseをraiseする</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">fwp_db.firewall_rulesを[]に設定し、rule_id_listで更新する</p>
</li>
<li><p class="first">fwp_db.firewall_rules.reorder()</p>
</li>
<li><p class="first">fwp_db.audited = False</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_process_rule_for_policy(self, context, firewall_policy_id, firewall_rule_db, position):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewall_policyからfirewall_ruleをinstertまたはremoveする</strong></p>
</li>
<li><p class="first">fwp_queryを取得する</p>
</li>
<li><p class="first">firewall_policy_idをキーとしてDBを検索し、先頭を得る</p>
</li>
<li><dl class="first docutils">
<dt>positionが真の場合</dt>
<dd><ul class="first last simple">
<li>fwp_db.firewall_rules.insert(position - 1, firewall_rule_db)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>positionが偽の場合</dt>
<dd><ul class="first last simple">
<li>fwp_db.firewall_rules.remove(firewall_rule_db)</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">fwp_dbをリオーダーする(fwp_db.firewall_rules.reorder())</p>
</li>
<li><p class="first">auditedをFalse(fwp_db.audited = False)</p>
</li>
<li><p class="first">fwp_dbをdictにして返す(return self._make_firewall_policy_dict(fwp_db))</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_get_min_max_ports_from_range(self, port_range):</dt>
<dd><ul class="first last simple">
<li><strong>説明：port_rangeを[min,max]にして返す</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_get_port_range_from_min_max_ports(self, min_port, max_port):</dt>
<dd><ul class="first last simple">
<li><strong>説明：[min,max]からport_range&#8221;min:max&#8221;にして返す</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_validate_fwr_protocol_parameters(self, fwr):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：protocol parameterのを行い、不正な場合はfirewall.FirewallRuleInvalidICMPParameterをraiseする</strong></p>
</li>
<li><dl class="first docutils">
<dt>fwr[&#8216;protocol&#8217;]がconst.TCPでない、かつ、const.UDPでない</dt>
<dd><ul class="first last simple">
<li>fwr[&#8216;source_port&#8217;] または、fwr[&#8216;destination_port&#8217;]が設定されている場合、firewall.FirewallRuleInvalidICMPParameterをraise</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>create_firewall(self, context, firewall):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewallの作成を行う</strong></p>
</li>
<li><p class="first">self._get_tenant_id_for_create(context, fw)でテナントIDを取得する</p>
</li>
<li><dl class="first docutils">
<dt>Firewallレコードを作成する</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>firewall_db = Firewall(id=uuidutils.generate_uuid(),</dt>
<dd><ul class="first last simple">
<li>tenant_id=tenant_id,</li>
<li>name=fw[&#8216;name&#8217;],</li>
<li>description=fw[&#8216;description&#8217;],</li>
<li>firewall_policy_id=</li>
<li>fw[&#8216;firewall_policy_id&#8217;],</li>
<li>admin_state_up=fw[&#8216;admin_state_up&#8217;],</li>
<li>status=const.PENDING_CREATE)</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">★idは指定できない！！！</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">self._make_firewall_dict(firewall_db)の実行結果を返す</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>update_firewall(self, context, id, firewall):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallのを更新を行う</strong></li>
<li>firewall情報をidをキーとして検索する</li>
<li>firewallをupdateする</li>
<li>self._make_firewall_dict(firewall_db)の実行結果を返す</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delete_firewall(self, context, id):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallの削除を行う</strong></li>
<li>firewall情報をidをキーとして検索する</li>
<li>firewallをdeleteする</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>get_firewall(self, context, id, fields=None):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallの情報を返す</strong></li>
<li>firewall情報をidをキーとして検索する</li>
<li>return self._make_firewall_dict(fw, fields)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>get_firewalls(self, context, filters=None, fields=None):</dt>
<dd><ul class="first last">
<li><p class="first"><strong>説明：firewallの情報を返す</strong></p>
</li>
<li><dl class="first docutils">
<dt>return self._get_collection(context, Firewall,</dt>
<dd><ul class="first last simple">
<li>self._make_firewall_dict,</li>
<li>filters=filters, fields=fields)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>get_firewalls_count(self, context, filters=None):</dt>
<dd><ul class="first last simple">
<li><strong>説明：firewallの個数を返す</strong></li>
<li>return self._get_collection_count(context, Firewall,filters=filters)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
</div>


    </div>
    <!-- /current document area -->
    <!-- sidebar -->
    
  <div id="sidebar" class="left">
    <div id="sidebarWrap">
  <div id="toc" class="sidebarRow">
  <h3><a href="index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">FWaaS internal</a><ul>
<li><a class="reference internal" href="#fwaas">FWaaSの構造</a></li>
<li><a class="reference internal" href="#firewall-l3-agent-fwaasl3agentrpccallback">firewall_l3_agent.FWaaSL3AgentRpcCallback ★エージェント側</a></li>
<li><a class="reference internal" href="#fwaas-driver">FWaaS driver処理 ★エージェント側</a></li>
<li><a class="reference internal" href="#class-firewallcallbacks-n-rpc-rpccallback">class FirewallCallbacks(n_rpc.RpcCallback) ★プラグイン側</a></li>
<li><a class="reference internal" href="#class-firewallagentapi-n-rpc-rpcproxy">class FirewallAgentApi(n_rpc.RpcProxy): ★プラグイン側</a></li>
<li><a class="reference internal" href="#class-firewallcountexceeded-n-exception-conflict">class FirewallCountExceeded(n_exception.Conflict): ★プラグイン側</a></li>
<li><a class="reference internal" href="#class-firewallplugin-firewall-db-firewall-db-mixin">class FirewallPlugin(firewall_db.Firewall_db_mixin): ★プラグイン側</a></li>
<li><a class="reference internal" href="#db">DBレコード構造★</a></li>
<li><a class="reference internal" href="#firewall-db-firewall-db-mixin">firewall_db.Firewall_db_mixin: ★プラグイン側</a></li>
</ul>
</li>
</ul>

  </div>
<div id="rel" class="sidebarRow">
  <div class="relRow prev">
  <h4>前のトピックへ</h4>
  <p class="topless"><a href="index.html"
                        title="前の章へ">Welcome to neutron internal&#8217;s documentation!</a></p>
  </div>
</div>
  <div id="source" class="sidebarRow">
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/fwaas.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
  </div>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
  </div>
    <!-- /sidebar -->
  </div>
  
  <!-- /content -->
</div>
  <!-- footer -->
  
  <div id="footer">
    <div class="footerCol">
      <h1><a href="index.html">neutron internal</a></h1>
      <p class="copy">
      &copy; Copyright 2014, kazuhiro MIYASHITA.
      </p>
      <p class="sp">
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2 で生成しました。
      </p>
    </div>
    <div class="footerCol">
    
  <div class="relbar">
    <dl id="relPrev">
      <dt class="prev">前のトピックへ</dt>
      <dd class="relTitle"><a href="index.html" title="前の章へ" accesskey="N">Welcome to neutron internal&#8217;s documentation!</a></dd>
    </dl>
  </div>
    </div>
  </div>
 
 <!-- /footer -->
</body>
</html>